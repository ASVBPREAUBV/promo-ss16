module Main where

import           Data.List (intersperse)

data Tree a = Empty | Node {label :: a, left, right :: Tree a}

data STree a = SNode a (STree a) (STree a) -- named node
             | SUNode  (STree a) (STree a) -- unnamed node
             | SEmpty

leaf :: a -> Tree a
leaf x = Node x Empty Empty

depth :: Tree a -> Int
depth Empty        = 0
depth (Node _ l r) = 1 + max (depth l) (depth r)


-- | Using a custom datatype to fill up the tree to the maximum depth
--   Example:
--            __6__
--           |     |
--          _7_    1
--         |   |
--         4   5

--   To:
--            __6__
--           |     |
--          _7_   _1_
--         |   | |   |
--         4   5 ?   ?

-- where ? is a custom Node with no value


toSTree :: Tree a -> STree a
toSTree tree          = sub tree (depth tree)
  where sub :: Tree a -> Int -> STree a
        sub (Node x l r) d = SNode x (sub l (d-1)) (sub r (d-1))
        sub (Empty) 0      = SEmpty
        sub (Empty) d      = SUNode (sub Empty (d-1)) (sub Empty (d-1))

showSTree :: Show a => STree a -> Int ->  [String]
showSTree tree dep = [printNodes   (dep-1) [tree]] -- first node is being generated by hand because it has no parents
             ++ showSTree' [tree]  (dep-2)         -- use the helper to go through the tree breath-first
  where showSTree' :: Show a => [STree a] -> Int -> [String]
        showSTree' _  n
          | n < 0  = []
        showSTree' [] _ = []
        showSTree' xs n = [printSeps  n (children xs)] -- seperators line
                  ++ [printNodes n (children xs)] -- nodes      line
                  ++ showSTree' (children xs) (n-1)

-- breath - first
children :: [STree a] -> [STree a]
children ((SNode _ l r) :xs) = [l,r] ++ children xs
children ((SUNode  l r) :xs) = [l,r] ++ children xs
children ( SEmpty       :xs) = children xs
children []                  = []

-- printing seperators
printSeps :: Int -> [STree a] -> String
printSeps n xs = concat $ intersperse " " (map toSep xs)
  where m = 2^n
        toSep (SNode _ _ _) = spc m ++ spc (m-1) ++ "|" ++ spc (m-1) ++ spc m
        toSep _             = spc m ++ spc (m-1) ++ " " ++ spc (m-1) ++ spc m

printNodes :: Show a => Int -> [STree a] -> String
printNodes n xs = concat $ intersperse " " (map toNode xs)
  where m = 2^n
        toNode :: Show a => STree a -> String
        toNode (SNode x (SNode _ _ _) (SNode _ _ _))  = spc m ++ uds (m-1) ++ show x ++ uds (m-1) ++ spc m
        toNode (SNode x (SNode _ _ _) _           )   = spc m ++ uds (m-1) ++ show x ++ spc (m-1) ++ spc m
        toNode (SNode x _            (SNode _ _ _))   = spc m ++ spc (m-1) ++ show x ++ uds (m-1) ++ spc m
        toNode (SNode x _            _       )        = spc m ++ spc (m-1) ++ show x ++ spc (m-1) ++ spc m
        toNode _                                      = spc m ++ spc (m-1) ++ " "    ++ spc (m-1) ++ spc m

-- underscores
uds :: Int -> String
uds n = replicate n '_'

-- spaces
spc :: Int -> String
spc n = replicate n ' '


instance Show a => Show (Tree a) where
    show tree = concatMap (++ "\n") (showSTree (toSTree tree) (depth tree))
--              |                   |_____________________________________|
--              |                                     |                   |
--              |                                  [String]               |
--              |_________________________________________________________|
--                                        |
--                    a long String with a '\n' after every line to match the 'show'-type


helper :: Show a =>  Tree a -> IO()
helper t = putStr $ show t

-- | This is obviously not the shortest / efficient solution, this is just a showcase!

-- | Examples
--   type in ghci 'showTree tree'

tree = Node 6 (Node 3 (leaf 2)
                      (Node 4 (leaf 5)
                               Empty))
              (Node 7 Empty
                      (Node 9 (leaf 8)
                               Empty))

t1 = Node 6 (Node 3 (leaf 2) (Node 8 (leaf 5) Empty))
            (Node 8 Empty (leaf 4))

t0 = Node 1 (Node 2 (leaf 3) (leaf 4))
            (Node 5 (leaf 6) (leaf 7))

t2 = Node 1 (Node 2 (Node 3 (leaf 3) Empty) Empty) Empty

t3 = Node 1 Empty (Node 2 Empty (Node 3 Empty (leaf 4)))

t4 = Node 1 (Node 2 (Node 3 (leaf 4) Empty) Empty)
            (Node 5 Empty (Node 6 Empty (leaf 7)))

t5 = Node 1 (Node 2 (Node 3 Empty (leaf 4)) Empty)
            (Node 5 Empty (Node 6 (leaf 7) Empty))

-- does not work well for two+ digit numbers, because I didn't think of it beforehand
-- and my algorithm is not suited to do that (tl;dr - I'm lazy)
t8 = Node 69 (leaf 77) (Node 44 (leaf 64) (leaf 7))

t9 = Node 6 (Node 3 (leaf 2) (Node 4 (leaf 5) Empty))
            (Node 7 Empty (Node 9 (leaf 8) Empty))


main :: IO ()
main = helper t9